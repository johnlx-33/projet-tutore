\documentclass[a4paper, 11pt]{report}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage[linesnumbered, french]{algorithm2e}
\usepackage{appendix}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsfonts}
\usepackage{amsmath}



\title{PROJET TUTORÉ\newline Reconstituer le théorème chinois en présence d’erreurs}
\author{Mr LAVOIX John, Mr GRANERO Fabien }
\date{7 mai 2021}

\begin{document}
\maketitle
\newpage
\begin{abstract}

Nous sommes étudiant en troisième année de licence mathématique et informatique. 
Suite au cours d'algèbres des années précédente 
et au cours de aritmétique et cryptologie de ce semestre, nous avons décidé d'approfondir nos connaissances dans le doamine des restes chinois.
De plus, voulant tout les 2 continuer nos études en poursuivant avec le master de cryptologie et sécurité informatique, ce projet fut l'occasion de découvrir les prémisses des enseignements dispensés dans ce master. \newline
\newline
\newline
Ce rapport est  une synthèse de nos travaux durant ce semestre, sur la reconstitution du théorème des restes chinois en présence d'erreurs.
Grâce au soutien de notre professeur Mr ZEMOR, qui nous a guidé tout au long de ce projet nous avons découvert et maitrisé plusieurs méthodes pour parvenir à notre objectif.
Pour ce faire, nous avons d'abord pris connaissance du théorème dans son ensemble. Puis dans un second temps, nous avons cherché et appris plusieurs facon de corriger le théorème des restes chinois lors de la présence d'erreurs.

\end{abstract}


\tableofcontents

\newpage

\begin{flushleft}
    Nous tenons tout d'abord à remercier monsieur CASTAGNOS Guillaume, d'avoir maintenu cette unité d'enseignement malgrès la situation sanitaire actuelle.  
Nous remercions par la suite monsieur ZEMOR Gilles de nous avoir formé durant cette période compliqué, d'être resté à notre écoute, et de nous avoir suivit tout au long de ce projet.
\newline 
Nous remercions également nos familles et nos proches, pour leurs aide et leurs soutiens moral.
\end{flushleft}


\chapter{théorème des restes}
\section{théorème des restes chinois et son histoire}
Les premières apparitions du théorème des restes chinois ont eu lieu au XIII° siècle  dans un livre de mathématique chinois de Qin JUSHIO publié en 1247. Cependant, on avait déjà découvert ce théorème auparavant dans un livre de Sun ZI au III° siècle. Le théorème consiste en:
On pose p1,...,pk des entiers premiers 2 à 2. Pour tout n1,...,nk, il existe un entier x tel que :
\newline
\newline
$ x\equiv n_1 \: (mod \;  p_1)$ 
\newline
$ x\equiv n_2 \: (mod \: p_2)$
\newline
$ x \equiv n_k \:(mod\: p_k)$
\newline
\newline
Il est difficile de trouver des applications immédiates au théorème des restes chinois. 
Pourtant il se révéle trés pratique dans des calculs à grandes échelles pour calculer trés rapidement 
en minimisant les possibilités d'erreurs de calcul ;
 ainsi qu'en cryptologie où la possibilité de faire des calculs sur de grands nombres avec des valeurs discrétes permet d'assurer une certaine sécurité si toutefois une partie des données fuitait.
Particuliérement dans le domaine des cartes à puces (cartes bancaires,badges ,cartes d'abonnements,...), oû il y a une interaction avec un terminale pour transmettre un code.
Il est très intéressant de délivré l'information souhaité par morceaux, surtout dans le cas ou le terminale ferait l'objet d'une attaque.
Alors dans ce cas si l'ensemble des données recupéré par l'attaquant n'est pas trop important alors il est impossible pour lui de les exploiter.
\newline
\newline
\newline
\newline
Nous allons dans un premier temps démontrer l'unicité de ce théorème.
\newline
Tout d'abord, nous cherchons l'existence d'une solution: \newline
On a $\forall k \in [1;y]  $, $x\equiv n_k (mod \: p_k)$ \newline
$\forall k \in [1;y] $, on note $P_k=\frac{P}{p_k} $ où $P=p_1 \times  ... \times p_y$ \newline
On voit assez simplement que $P_k$ et $p_k$ sont premiers entre eux car tous les entiers $p_i$ sont premiers entre eux 2 à 2. Donc $P_k$ est inversible modulo 
$p_k$, car en faisant le théorème d'euclide, on va trouver $u,v\in \mathbb{Z}$ tel que $P_k\times u + p_k \times v = d$ avec d le PGCD. Or $P_k$ et $p_k$ sont premiers entre eux donc $d=1$ et on trouve facilement l'inverse de $P_k$ modulo $p_k$. \newline
On note alors $u_k$ le nombre tel que $u_k\times P_k + v_k\times p_k= 1$, soit $u_k\times P_k\equiv 1(p_k)$. \newline
Soit $x=\sum_{k = 1}^{y} u_k\times P_k\times n_k$. On pose $i\in [1;y]$ et $k\neq i$ alors $P_i\equiv 0(mode \: p_k)$ car $P_i=p_1\times ... \times p_k \times ...\times p_y$. \newline
On a donc $x\equiv u_i P_i a_i(mod \: p_i)$, mais on sait que $u_i P_i\equiv 1 (mod \: p_i)$ d'où $x\equiv a_i (mod \: p_i)$. Sachant que cette équation est vraie pour tout i, on a x solution du système. \newline
Par conséquent, nous avons prouvé l'existence d'une solution.

Ensuite, nous montrons l'unicité du système. \newline
On a x une solution du système, posons y une autre solution du système. On a alors $x-y\equiv 0( mod p_k)$, soit $p_k$ divise $x-y$. Sachant que les $p_k$ sont premiers 2 à 2 entre eux, on a donc $x-y\equiv 0(mod \: P)$, donc P divise x-y, ou encore que $x\equiv y (mod \: P)$. Par cela, nous avons montré l'unicité modulo P.
\newline
\newline
\newline
\newline
\newline
Pour illustrer ce théorème, nous allons donner un exemple, extrait du livre de Sun ZI qui a proposé une solution.
\newline
Choisissons des objets comme des bonbons: si on les répartit pour 3 enfants, il en reste 2, si on les répartis
pour les 3 enfants et leurs parents (soit 5 personnes), il en reste 3. Enfin si on rajoute les 2 cousins
(soit 7 personnes), il reste alors 2 bonbons. On a donc :
\newline 
\newline
$ x\equiv 2 \: (mod \:  3)$ 
\newline
$ x\equiv 3 \: (mod \: 5)$
\newline
$ x\equiv 2 \:(mod\: 7)$
\newline
\newline 
La question que l'on se pose à présent est : combien y a t'il de bonbons?
\newline
Grâce au théorème des restes chinois, on peut trouver la réponse. Nous avons en réalité plusieurs réponses, c'est-à-dire que tout les nombres congrus à x modulo N sont des bonnes réponses.
Avant de répondre à ce problème, il faut tout d'abord examiner l'algorithme.



\newpage

\section{Notre algorithme}
Notre fonction en Python du théorème des restes chinois étant un peu lourde,
nous allons montrer l'algorithme ci-dessous (voir annexe A).
On obtient donc :
\newline
Soit $p_i$ le i-ème terme de la liste des modulos, on note \newline
$ P_i=\frac{p}{p_i}=p_1 p_2 ... p_{i-1} p_{i+1} ... p_k $   \newline
on a donc $P_i$ et $p_i$  qui sont premiers entre eux. \newline
Il faut alors faire l'algorithme d'Euclide étendu sur $P_i$ et $p_i$, ce qui nous donne: 
$1= P_i u_i + p_i v_i$ 
où 
$u_i, v_i \in  \mathbb{Z}  $
\newline
On pose donc $e_i = u_i P_i$ avec $ e_i \equiv 1 \; (mod \; p_i)$ et $ e_i\equiv 0 \; (mod \; e_j)$ avec $ i\neq j$ \newline
On trouve alors une solution qui est $x=\sum_{i = 1}^{k}{p_i e_i} $.\newline
\newline
\newline
Nous pouvons à présent répondre à l'exemple précédent. Nous avions: \newline
$ x\equiv 2 \: (mod \:  3)$ 
\newline
$ x\equiv 3 \: (mod \: 5)$
\newline
$ x \equiv 2 \:(mod\: 7)$
\newline
On obtient $P_1=5\times 7=35$, $P_2=3\times 7=21 $, et $P_3=3\times 5=15$ \newline
On fait l'algorithme d'Euclide étendu sur $P_1$ et $p_1$ qui donne $-3\times 23 +2\times 35\times 1= 1 $, par conséquent on trouve $e_1=2\times 35$ \newline
Idem sur $P_2$ et $p_2$ qui donne $21\times 1 - 5\times 4=1$, donc $e_2=21$ \newline
Enfin, on a $15\times 1- 7\times 2 = 1 $ avec $e_3=15$ \newline
Le résultat est $x=2\times 35 + 3\times 21 + 2\times 15 =233$.
Nous avons, comme dit précédement, plusieurs résultats qui sont les entiers congrus à 233 modulo 105. \newline
$233\equiv 23 (mod \: 105)$ \newline
Le résultat final est donc $23+105k$, $k \in \mathbb{Z} $.
Si on reprend notre problème, on a donc 23 bonbons.
\newline
\newline
Comme vous pouvez le voir, nous avons utilisé l'algorithme d'Euclide étendu. Celui-ci prend en paramètres a et b, deux entiers.
Il renvoit $d$ le PGCD de $a$ et $b$ et un couple $(u,v) \in \mathbb{Z} $ tel que $d=au+bv$.
\newline
Pour notre utilisation, nous avons un peu modifié cet algorithme, car pour utiliser le théorème des restes chinois, les nombres sont premiers entre eux 2 à 2,
donc $d=1$. De plus, il nous fait gagner une étape car il nous renvoit l'inverse de a modulo b.

\begin{algorithm}
    \caption{algorithme d'euclide étendu}
    \begin{algorithmic}
        \STATE $x_0 \leftarrow 1 $ 
        \STATE $x_1 \leftarrow 0 $
        \STATE $y_0 \leftarrow 0 $ 
        \STATE $y_1 \leftarrow 1 $ 
        \STATE $s \leftarrow 1 $ 
        \STATE $d \leftarrow b $
        \WHILE{$b\neq 0$}
        \STATE $ (q,r) \leftarrow divmod(a,b) $  /* q est le quotient et r le reste de la division euclidienne de a par b */ 
        \STATE $ (a,b) \leftarrow (b,r) $ 
        \STATE $ (x,y) \leftarrow (x_1,y_1)$ 
        \STATE $ (r_1,y_1) \leftarrow (q\times s1 + x_0 , q\times y_1 + y_0) $
        \STATE $ (x_0,y_0) \leftarrow (x,y)$ 
        \STATE $ s \leftarrow -s$ 
        \ENDWHILE
        \RETURN {$s\times x_0 + ((1-s)\div 2)\times d$}
    \end{algorithmic}

\end{algorithm}
\newpage

Maintenant que nous avons présenté les algorithmes principaux du théorème des restes chinois, voici quelques fonctions que nous pourrions qualifier de secondaires au premier abord, mais très utiles dans certains cas. \newline
En premier, nous avons fait un algorithme s'intitulant générateur de cas, qui prend en argument 2 nombres et qui génère les listes des nombres premiers entre eux, et la liste des restes modulo les $p_i$. C'est en
quelque sorte la fonction inverse du théorème des restes chinois. 

\begin{algorithm}
    \caption{algorithme d'encodage}
    \begin{algorithmic}
        \REQUIRE $n>k$
        \STATE $l_n= nombre-facteur-premier(n)$
        \STATE $l_k=[]$
        \FOR {i in range(len(ln))}
        \STATE $l_k=l_k +[k/ln(i)]$
        \ENDFOR
        \RETURN {($l_n$, $l_k$)}
    \end{algorithmic}

\end{algorithm}

Par exemple notre algorithme d'encodage sur $(30030,61)$ renvoie les listes $P=[2,3,5,7,11,13]$ et la liste $N=[1,1,1,5,6,9,10]$ ,
qui représente la liste des facteurs premiers qui composent 30030 et la représentation de 61 modulo les élements de P .  \newline

Nous pouvons remarquer que dans la fonction au dessus, nous utilisons la fonction nombre facteur premier qui prend en paramètre un nombre n et renvoie la liste des ses facteurs premiers. 

\begin{algorithm}
    \caption{nombre facteur premier}
    \begin{algorithmic}
        \STATE $l=[]$
        \STATE $i=2$
        \WHILE {$n\neq 1$} 
        \STATE $c=1$
        \WHILE {$n\%i=0$}
        \STATE $n=n//i$
        \STATE $c=c\times i$
        \ENDWHILE
        \IF {$(n\times c) \%i= 0$} 
        \STATE $l=l+\left[c\right] $
        \ENDIF
        \STATE $i=i+1$
        \ENDWHILE
        \RETURN{$l$}
    \end{algorithmic}
\end{algorithm}

Par exemple nombre facteur premier (210) renvoie la liste $[2,3,5,7]$ car $210=2\times 3\times 5\times 7$

\newpage
\chapter{}{Presentation du problème}
section{Le probléme et ses restrictions}
\hbox{Le théorème des restes chinois induit une bijection :}
\begin{center}
  

$[0,N-1] \rightarrow \mathbb{Z}/ p_{1 \mathbb{Z}} \times  ... \times   \mathbb{Z}/ p_{i \mathbb{Z}} $  \newline
$x \rightarrow (x_1,...,x_i) $ 

\end{center}

Oû $ x\equiv x_i \: (mod \: p_i)$
\newline

Malheuresement nous ne pouvons encoder l'ensemble $[0,N-1]$ dans son entièreté et être capable de corriger et faire face aux erreurs.\newline
A  propos du N à choisir ce qui nous intéresse dans le N choisi c'est un N entier produit de plusieurs nombres premiers.\newline 
Car plus il y a de nombres premiers qui composent N plus le systéme des restes chinois engendré par ce N contient d'équations.  \newline
Tout les nombres de 0 à N-1 ne peuvent pas être "encodés" si l'on veut corriger des erreurs.\newline
Il faut determiner une borne B comprise entre 0 et N-1 qui nous servira de "zone" d'encodage.\newline
Pour determiner cette borne on a 2 maniéres :\newline
la premiére est de choisir N et de trouver B en se restreingnant à une sous partie du systéme, le surplus servant de "donnée de parité" ;\newline
la deuxième est de choisir B l'ensemble des entiers que l'ont veut encoder et rajouter des informations donc des équations supplémentaires au systéme engendré par B, donc multiplier B par d'autres nombres premiers.\newline

\newpage

\section{Comment déterminer la borne}


Maintenant comment déterminer B de façon calculatoire ? \newline
Soit $N=p_1\times ...\times p_n$
On pose $x=p_1 \times p_2 \times ... \times p_{n-2t}$ où t est le nombre d'erreurs. \newline
On note la représentation de x par le théorème des restes chinois $m=(0...0 a_1 a_2 ... a_t ... a_{2t})$ \newline
On reçois le message $r=(0...0 a_1...a_t 0...0)$ \newline
Nous obtenons 2 possibilités d'erreurs, soit: \newline
- $(0...0 a_1...a_t 0...0) $ avec des erreurs sur le t-uplets de $a_1$ à $a_t$, qui correspond à l'encodage de 0. \newline
- $(0...0 a_1...a_t a_{t+1}...a_{2t})$ avec des erreurs sur le t-uplets de $a_{t+1}$ à $a_{2t}$, qui correspond à l'encodage de $x$. \newline
Donc la borne est x pour ne pas laisser de doute au moment de la correction. \newline
\newline
Pour illustrer cette détermination de borne, voici un petit exemple: \newline
Posons $N=2\times 3\times 5\times 7\times 11\times 13 \times 17= 510510$ et $t=2$. \newline
On trouve $x=2\times 3\times 5=30$. Donc pour 2 erreurs, la borne de N est 30.


Dans les algorithmes que vous verrez dans la suite de notre travail, vous pourrez trouver nos calculs de borne. Cependant, ces calculs sont propres à chaque algorithme,
c'est à dire que la borne pour un même nombre et un même nombre d'erreurs peut varier en fonction des algorithmes utilisés. \newline
Mais, on peut calculer mathématiquement la borne maximale. \newline
Soit t le nombre d'erreurs et 
Cela signifie que après cette borne, la correction d'erreurs marche parfois, ce n'est donc plus une valeur sur à cent pour cent, alors que avant cette borne, oui.
\newline
La question que nous sommes à présent en droit de nous poser est, est-ce qu'il existe une borne tel que l'on ne puisse corriger aucun nombre supérieur à cette borne. Et la réponse est oui.
Partons d'un n-uplet de départ $x=(x_1, x_2, ..., x_n)$. On pose également, dans le n-uplet reçu, $y$ le résultat possible avec t erreurs. Avec bien sûr, le cardinal des n-uplets reçu qui est infèrieur à la sommes des $p_i$. Dans les n-uplets reçus, il y a un nombre $D$ de résultats possibles. Nous cherchons donc à calculer $D$, qui vaut: \newline
$D=\sum_{I \subset  [n]  \newline |I|=t  }  \prod _{i \in I} p_i - 1 \simeq  \binom{n}{t} p^t  $ avec $[n]$ les entiers de 1 à n et $p=p_n$\newline
Par exemple si $x=(x_1, x_2, x_3, x_4)$ et $t=2$ alors $D=(p_1-1)(p_2-1)+(p_3-1)(p_4-1)+(p_1-1)(p_3-1)+(p_1-1)(p_4-1)+(p_2-1)(p_3-1)+(p_2-1)(p_4-1)$ \newline
On a donc $ |recu| \simeq |B| \times D\leq \sum_{i = 1}^{n} p_i  $ \newline
Donc la borne absolue vaut : $|B| \leq  \frac{\sum_{i= 1}^{n} p_i }{D} $.\newline
Idem que précédement, faisons un petit exemple. \newline
Posons $N=2\times 3\times 5\times 7\times 11\times 13$ et $t=2$, alors $D\simeq \binom{6}{2}\times 13^2=2535$
$B \leq  \frac{2\times 3\times 5\times 7\times 11\times 13}{D}=\frac{510510}{2535} \simeq 201 $.


\newpage

\chapter{section}{Brute force}

Il existe plusieurs algorithmes de brut force qui permettent de résoudre les erreurs tel que essayer tout les cas possibles. Mais cet algorithme est trop lourd à écrire. Nous avons donc fait des algorithmes moins lourd.
Nous vous présenterons deux algorithmes dans cette section.

\section{Notre premier algorithme version naïve }
Tout d'abord, nous avons fait une fonction qui nous montre s'il y a une erreur dans nos listes, car avant de vouloir trouver les erreurs, il faut savoir s'il y en a une (voir annexe B).
Nous avons donc fait un petit algorithme qui permet d'enlèver alternativement un élément des listes. Autrement dit, on retire le premier élément des deux listes, puis on retire que le deuxième élément, puis que le troisième et ainsi de suite. Nous appliquons alors le théorème des restes chinois à chaque itération. Puis on mets le résultat dans une liste auxiliaire. S'il n'y a pas d'erreur,
lorsqu'on retourne cette liste auxiliaire, on devrait avoir la même valeur partout, en revanche si les valeurs de la liste sont différentes, nous avons une erreur. \newline
\newline
Soit $P=[p_1 , p_2, ... , p_k]$ et $N=[n_1, n_2, ..., n_k]$ \newline
On note $P_i = [p_1,..., p_i-1, p_i+1, p_k]$ et $N_i=[n_1,..., n_i-1, n_i+1, ... , n_k]$ \newline
On note $x_i$ le résultat théorème des restes chinois appliqué à $P_i$ et $N_i$ \newline
Puis on retourne 
$L=[x_1, ..., x_k]$ \newline
Si 
$x_1=x_2=...=x_k$ 
alors il n'y a pas d'erreur. \newline
\newline
Voici un petit exemple pour bien comprendre cette fonction.\newline
On pose P=[2,3,5,7,11,13] et N=[1, 1, 1, 5, 6, 9] \newline
Si on applique le théorème des restes chinois à ces deux listes, on trouve 510510. Pour vérifier qu'il n'y ai pas d'erreur, on applique le théorème à
P1=[3,5,7,11,13] et N1=[1, 1, 5, 6, 9, puis à P2=[2,5,7,11,13] et N2=[1, 1, 5, 6, 9] jusqu'à P6=[2,3,5,7,11,] et N7=[1, 1, 1, 5, 6]\newline
Comme il n'y a pas d'erreur, la fonction va retourner [61, 61, 61, 61, 61, 61] \newline
À présent, nous mettons une erreur dans les listes, on a P=[2,3,5,7,11,13] et N=[1,1,2,5,6,9]. En appliquant la fonction, il sera retourner une liste [6067, 6067, 61, 1777, 607, 1447], où l'on remarque bien que chaque élément est différrent, donc nous avons au moins une erreur.
Dans cette fonction, on parcours n fois la liste de n élément donc nous somme en $O(n^2)$. Mais on fait n fois l'algo des restes chinois donc on est en $O(n^2)$. Cette algorithme est donc en $O(n^4)$ avec n la taille de la liste.
Cette fonction à éaglement une borne qui est $ \prod_{i=1}^{n-1} p_i $.
\newline 
\newline
Pour créer notre première fonction de correction, nous nous sommes inspirées de la fonction ci dessus (voir annexe C). On sait dit que si on enlevé 2 élément des listes, nous pourrions trouver l'erreur. On s'explique;
On a vu que si on enlevais 1 éléments des listes, le théorème des restes chinois marchait encore, et si on enlève 2 éléments, il marche encore. Donc, en enlevant le premier élément et tout les autres chacun leurs
tours, et en appliquantle théorème à chaque fois, on retourne une liste. Puis, on réitére en enlevant le deuxième élément, et les autres chacun leurs tours, en re-appliquant les restes chinois à chaque fois, en mettant les résultats dans
une nouvelle liste. Ainsi de suite jusqu'au dernier élément. Cette fonction retourne une liste de liste. Donc la liste où se trouve le même nombre partout, c'est que l'erreur est à la meme position.
faisont plutôt exemple.
\newline 
Soit $P=[p_1, p_2, ... , p_k]$ et $N=[n_1 , n_2, ... ,n_k]$ \newline
On note $P_ij =[p_1 , ... , p_i-1 , p_i+1 , ... , p_j-1 , p_j+1 , ... , p_k]$ et $N_ij=[n_1, ..., n_i-1, n_i+1, ..., n_j-1, n_j+1, ..., n_k]$ \newline
On note $x_ij$ le résultat du théorème des restes chinois appliqués à $P_ij$ et $N_ij$ \newline
Et on retourne $L=[[x_11,x_12,...x_1k],[x_21,x_22,...,x_2k],...,[x_{1k},x_{2k},...,x_{kk}]]$ \newline
On a retourné une liste de liste. Si la k-ième sous-liste retourne toujours le même nombre alors cela signifie qu'il y a une erreur sur le k-ième élément. \newline`
\newline
Si on récupère l'exemple du paragraphe précédent, où l'on avait découvert une erreur. \newline
On a: $P=[2,3,5,7,11,13]$ et $N=[1,1,2,5,6,9]$ \newline
On applique notre algoritme et il retourne/
[[6067, 1062, 61, 1777, 607, 292], [1062, 6067, 61, 347, 607, 677], [61, 61, 61, 61, 61, 61], [1777, 347, 61, 1777, 217, 127], [607, 607, 61, 217, 607, 187], [292, 677, 61, 127, 187, 1447]] \newline
La première liste retourné ne renvois pas le meme résultat donc l'erreur n'est pas sur la première équation. Elle n'es pas non plus sur la deuxième équation.
Cependant, on peut voir sur la troisième liste que le résultat est toujours le même; c'est à dire qu'à chaque fois on a fait le théorème des restes chinois en enlevant la troisième équation et une autre, donc nous avons une erreur sur la toisième équation.
\newline
Voici un exemple d'échec de notre algorithme pour des valeurs prisent en dehors de la borne.
si $N=[0, 2, 0, 5, 9, 11]$ la liste qui représnete 2000 modulo les $p_i$. Posons un erreur sur $N$, tel que $N=[0, 2, 0, 6, 9, 11]$ l'algorithme renvoie 
[[12725, 2715, 713, 2000, 440, 20], [2715, 7720, 1714, 570, 440, 20], [713, 1714, 3716, 284, 440, 20], [2000, 570, 284, 2000, 50, 20], [440, 440, 440, 50, 440, 20], [20, 20, 20, 20, 20, 20]]
Comme on l'observe, l'algorithme trouve parfois 2 000 mais ne trouve pas l'erreur, ou du moins, il en trouve une mauvaise.
\newline
Cette fonction est très performante comme vous avez pu le voir sur les exemples, cependant il y a quelque défaut. Premièrement, cette fonction ne marche que avec une seule erreur,
on peut facilement changer la fonction pour trouver n erreur juste en rajoutant des boucles FOR, mais cela rendrait l'algorithme encore plus lourd et une borne très faible. Deuxièmement, nous avons un problème de borne. Pour trouver la borne,
il suffit de multiplier par les 2 derniers nombre premier de la liste. \newline
Par exemple pour le nombre 30030, la borne est 30030/(11x13) soit 210, se qui est très peu.\newline
Enfin, nous avons un problème de complexité soit $O(n^3)$ et a chaque fois on fait le théorème des restes chinois qui est en $O(n^2)$, se qui donne un algorithme en $O(n^5)$.




\newpage
\section{brute force de hamming}

Notre deuxième algorithme brut force consiste à utilisé la distance de hamming. Soit $x=x_1x_2 ... x_n$ et $y=y_1y_2 ... y_n$, la distance de Hamming c'est
$d_H(x,y)=Card\{  i\vert x_i \neq y_i \}$. Par exemple la distance de Hamming de $x={1,2,3,4}$ et $y={1,2,5,6}$ est 2\newline
Avant de voir cette algorithme, nous devons expliquer la distance minimale. Soit G un groupe n-uplet appartenant à $A^n$. La distance minimale de G est la plus petite distance de hamming sur tout les éléments de G, soit $d(G)=min{\left\{d_h(x,y)\right\} | x\neq y, x,y\in G}$.
D'après Hamming, si la distance minimale est égal à d, alors on peut détecter d-1 erreurs et corriger $\frac{d-1}{2}$ erreurs. \newline


Dans cette algoritme nous utilisons la distance de haming qui prend en entré 2 listes de nombres nommés $A1$ et $A2$, et retoune le distance de Hamming. Du coup, il nous a fallu le coder. \newline
\begin{algorithm}
    \caption{distance de hamming}
    \begin{algorithmic}
        \STATE $n=min(len(A1),len(A2))$
        \STATE $m=max(len(A1),len(A2))$
        \STATE $cpt=m-n$
        \FOR{i in range(n)}
        \IF{$A1[i]\neq A2[i]$}
        \STATE $cpt=cpt+1$
        \ENDIF
        \ENDFOR
        \RETURN{cpt}        
    \end{algorithmic}
\end{algorithm}

Pour ce nouvel algoritme (voir annexe D), nous allons calculer la distance de Hamming entre le uplet à corriger et tout les élements de 0 à la borne. Nous selectionnons tout les éléments de distance de Hamming strictement inférieur à 3 pour pouvoir détecter une erreur. \newline
Pour choisir la borne de cette algorithme pour 1 erreur, on retire les 3 plus grandes équations, c'est à dire si $P=[p_1, ..., p_k]$ alors la borne est $\prod_{i=1} ^{k-3} p_i$. Pour e erreurs, on retire les $3e$ dernières équations. \newline
Faisons un exemple pour illustrer cette algoritme: \newline
Prenons les listes $P=[2,3,5,7,11,13,17]$ et $N=[1,0,0,5,9,10,7]$ pour nos exemples. \newline
Détaillons, pour mieux le comprendre, notre algorithme sur $N=[1,0,0,5,7,10,7]$ c'est à dire que nous mettons une erreur sur le cinquième thermes.
Dans un premier temps, l'algorithme va faire la distance de Hamming entre la liste N et le nombre 0 qui s'écrit $L_O=[0,0,0,0,0,0,0]$ car le reste dans division euclidienne des $p_i$ par 0 est toujours 0.
La distance de hamming de ces 2 listes est 5, car 2 éléments sur les 7 sont identiques entre les 2 listes, donc on ne prete pas attention à ce cas. \newline
On fait la distance de hamming entre le liste N et 1 qui s'écrit $L_1=[1,1,1,1,1,1,1]$ car le reste dans la division euclidienne des $p_i$ par 1 est toujours 1.
La distance de Hamming de ces 2 listes est 6 donc on ne prete pas attention.
On fais la distance de Hamming entre la liste N et 2 qui s'écrit $L_2=[0,2,2,2,2,2,2]$. La distance de Hamming de ces 2 listes est 7 donc on ne prete pas attention. \newline
Il continue ses recherches sur les entiers 3, 4, et ainsi de suite. L'algorithme à découvert une liste qui avait une distance de Hamming infèrieur à 3. Cette liste est la liste $L=[1,0,0,5,9,10,7]$ qui correspond au nombre 75. Donc 75 est un candidat possible à la correspondance de cette uplet.
l'algorithme va continuer ces tests sur tout les nombres jusqu'à notre borne moins 1 qui ici vaut $2\times 3\times 5\times 7 -1=209$. \newline
\newline
De même que pour l'algorithme précédent, voici le même exemple. \newline
Rapelons les faits, $N=[0, 2, 0, 5, 9, 11]$, et on implémente une erreur qui est: $N=[0, 2, 0, 6, 9, 11]$.
L'algorithme retourne [20], c'est une nouvelle fois une erreur.
\newline
La complexité de cette algorithme se calcul assez rapidement. Nous avons une boucle while, on fait donc $b$ fois la distance de Hamming. LA distance de Hamming est donc $O(r)$ où r est la taille du système. On a donc cette algorithme 
qui est en $O(b\times r)$.




\newpage
\chapter{Les fractions continues} 
\section{Définition}
Comme vu précédement la méthode brute force est efficace sur des petits cas de 
correction mais sur de cas plus grand la complexité explose et il est très difficile d'obtenir des résultats en un temps raisonnable.\newline
Il faut donc trouver un moyen plus rapide et optimal. Donc comprenons comment intervient l'erreur sur le n-uplet du systéme d'équation.\newline
Soit m le message envoyé et y le message et l'erreur dans le même message. si l'on fait la différrence de m-y on obtient e l'erreur.
Maintenant cette erreur ce représente par un uplet en supposant par soucis de représentation que les erreurs se trouve au début de l'uplet associé
$e = [e1,e2,e3,...,e_k,0,...,0]$ cette erreur est donc un multiple de tout les $p_i$ nombres premiers pour i>k et k  reste non nul sur les positions erronés.\newline
Donc $y = m + e$ donc si l'on divise y par N notre entier on a $\frac{y}{N}=\frac{m}{N}+\frac{e}{N}$\newline
mais $\frac{e}{N}$ peut se simplifier car hormis les positions érronés 2 dans notre cas e est un multiple de tout les autres $p_i$ qui composent N\newline
Ainsi on a  $\frac{y}{N}=\frac{m}{N}+\frac{e}{N}=\frac{m}{N}+ \frac{e_1 * e_2}{p_1 * p_2 } <\frac{B}{N} $    B étant la borne choisis.\newline
Finalement $\frac{m}{N}=\frac{y}{N} - \frac{e_1 * e_2}{p_1 * p_2 } $ \newline
\newline
Or souvenons-nous que si z est un réel positif et que la fraction rationnelle $\frac{p}{q}$
vérifie $ \left| z - \frac{p}{q} \right| < \frac{1}{2q^2} $. 
Alors $\frac{p}{q}$ est une fraction reduité de z.\newline
\newline

Appliquer à notre probléme chaque réduite de cette fraction liste au dénominateur des candidats potentiels pour les positions érronés.\newline
Lors de l'écriture des fractions continues en pyhton, nous avons du faire appelle à des foncitons segondaires (voir annexe 5). Tout d'abord, il nous a fallu une petite fonction qui calcul la borne maximal pour cette méthode.
\begin{algorithm}
    \caption{borne maximale pour les fractions continues}
    \begin{algorithmic}
        \STATE $borne=1$
        \FOR{i in range(len(N)-1,len(N)-t-1,-1)}
        \STATE $borne=borne\times N[i]$
        \ENDFOR
        \RETURN{borne}
    \end{algorithmic}
\end{algorithm}    
\newpage
Dans un segond temps, nous avons utilisé la fonction réduite qui prend en paramètres les 3 entiers $k$, $n$ et $p$ et renvoie $l$ la liste .
\begin{algorithm}
    \caption{fraction reduite}
    \begin{algorithmic}
        \STATE $a=k$
        \STATE $b=n$
        \STATE $q=1$
        \STATE $r=1$
        \STATE $l=[]$
        \STATE $n=0$
        \WHILE{$n<p$}
        \STATE $q=a//b$
        \STATE $r=a\%b$
        \STATE $l=l+[q]$
        \STATE $a=b$
        \STATE $b=r$
        \STATE $n=n+1$
        \IF{r=0}
        \RETURN{l}
        \ENDIF
        \ENDWHILE
        \RETURN{l}
    \end{algorithmic}
\end{algorithm}
Et enfin, nous retrouvons la fonction liste-int-réduite qui prend en paramètre l, retourné par la fonction d'avant et qui renvois 2 entiers
\begin{algorithm}
    \caption{liste entier réduite}
    \begin{algorithmic}
        \STATE $h_2=0$
        \STATE $h_1=1$
        \STATE $k_1=0$
        \STATE $k_2=1$
        \STATE $hp=0$
        \STATE $kp=0$
        \FOR{i in range(len(l))}
        \STATE $hp=l[i]\times h_1+h_2$
        \STATE $kp=l[i]\times k_1+k_2$
        \STATE $h_2=h_1$
        \STATE $h_1=hp$
        \STATE $k_2=k_1$
        \STATE $k_1=kp$
        \ENDFOR
        \RETURN{hp,kp}
    \end{algorithmic}
\end{algorithm}

Maintenant parlons de la complexité de cette méthode. 
On parcours la liste des derniers nombres premiers du systéme, pour calculer une borne à ne pas dépasser au denominateur de la fraction cela reduit drastiquement les itérations à faire.
Une fois cette borne determiné on calcule les reduites de  $\frac{y}{n}$ sans que le denominateur qui sert d'indication sur la position des erreurs ne depasse la borne.
A chaque tour de boucle on calcule une reduite qui coute l'ordre de la réduite fois le coût d'une division euclidienne  ,
l'algorithme permettant de calculé une réduite étant une version modifié de l'algorithme d'Euclide arrété à l'ordre de la fraction réduite voulue.
Donc finalement pour calculer toutes les réduites qui mettent en évidence les potentiels position érronés le coût et relativement faible car dépend de la taille du systéme lineairement donc relativement faible et rapide.
Coût que l'on a constater grâce  nos experiences et test. \newline





\newpage
\section{Résumé d'experiences et test}
Au début de nos tests nous avons pratiqué avec des petits cas de 6 à 7 nombre premier et cette méthode ne se révéla pas très efficace. Du aufait que le système étudié est trop petit, la méthode des fractions continues échoue par manque d'équation.
Mais pour tester des cas avec plus d'erreurs nous avons eu besoin de systéme plus grand, nous avons donc directement étendu notre systéme à 51 nombres premiers.
Nous avons pris la borne B = $10^{29}$ ordre de grandeur de la borne théorique pour corriger 15 erreurs.
Dans ce cas et grâce à la méthode des fractions continue nous avons étè en capacité de corriger jusqu'à 7 erreur. \newline
Voici quelque exemple: \newline 
Pour le premier exemple, nous avons choisi de travailler avec les 20 premiers nombre premier, et $[1, 2, 1, 1, 0, 8, 1, 18, 4, 23, 10, 12, 6, 0, 9, 51, 50, 26, 61, 61]$ le n-uplet avec 2 erreurs.
L'algorithme retoune $[[2], [3, 43]]$. On reconstitue le thèorème en enlevant, dans un premier temps l'équation du modulo 3. Et dans un autre temps, nous avons fait le théorème en retirant 
les équations modulo 3 et 43. Nous avons deux valeurs retourné, suite à la reconstitution du thèorème, qui sont 2162561357080315373769686 pour la première et 86842888231 pour le segond. Le bon résultat étant le plus petit, cela 
signifie que l'erreur est sur l'équation modulo 3 et modulo 43. \newline
\newline


De plus, on pose pour les $p_i$ les 50 premiers nombres premiers, et 
$N=[0, 2, 0, 4, 7, 1, 16, 2, 22, 25, 26, 34, 18, 19, 30, 24, 24, 22, 52, 56, 4, 15, 54, 68, 
89,\newline 58, 39, 15, 54, 11, 112, 73, 134, 126, 102, 142, 142, 92, 159, 48, 119, 33, 16, 77, 28,
 \newline 29, 67, 89, 86, 163, 150]$ le n-uplet reçu, c'est à dire avec des erreurs(7). 
Les erreurs sont sur les positions correspondant aux nombres premiers de la liste suivante $[7, 79, 97, 107, 127, 157, 223]$. 
L'algorithme retourne $[[5], [2, 7], [3, 11], [7, 79, 97,\newline 107, 127, 157, 223]]$. Comme nous pouvons l'observer, l'algorithme à trouvé la bonne réponse. Cependant il propose d'autres cas. Par le même biais que l'exemple précédent, nous trouver que la bonne solution est le 7-uplets.


\newpage
 
\chapter*{Conclusion}
Finalement on peut distingué 2 cas. Premiérement si l'on doit corriger quelques erreurs sur un petit système 
les méthodes brute force évoquées précédement sont a préconiser malgrés leur coût trés élevé
et dans un second cas sur des systéme plus grand de taille 20 ou plus avec plus d'erreur alors la méthode des fractions continue
se révéle beaucoup plus efficace voir nécessaire pour ésperé avoir un résultat comparé au méthode brut force.
Dans des cas concret appliqué a la vie de tout les jours on ce retrouve face a des grands cas comme dans le domaine des cartes a puces ect ..
alors la méthode des fraction continue est à choisir .
\newpage

\chapter*{Annexes}
\begin{appendices}
    Annexe 1
    \begin{algorithm}
        \caption{algorithme du théorème des restes chinois}
        \begin{algorithmic}
            \REQUIRE $len(P)=len(N)$
            \STATE $b=0$
            \FOR {i in range(len(N))}
            \STATE $p_i=1$
            \STATE $pi=P[i]$
            \STATE $k=1$
            \FOR {j in range(len(N))}
            \IF {$j\neq i$}
            \STATE $p_i=p_i\times P[j]$
            \ENDIF
            \ENDFOR
            \WHILE {$k\times p_i \neq pi\times y +1$ }
            \STATE $k=k+1$
            \ENDWHILE
            \STATE $b=b+k\times p_i \times N[i] $
            \ENDFOR
            \RETURN{$b$}
        \end{algorithmic}
    \end{algorithm}
\end{appendices}

\newpage

\begin{appendices}
    Annexe 2
    \begin{algorithm}
        \caption{algoritme pour savoir s'il y a une erreur}
        \begin{algorithmic}
            \REQUIRE $len(P)=len(N)$
            \STATE $L=[]$
            \FOR {i in range(len(N))}
            \STATE $N1=[]$
            \STATE $P1=[]$
            \FOR {j in range(len(N))}
            \IF{$i\neq j$}
            \STATE $N1=N1+[N[j]]$
            \STATE $P1=P1+[P[j]]$
            \ENDIF
            \ENDFOR
            \STATE $l=reste-chinois(N1,P1)$
            \STATE $L=L+[l]$
            \ENDFOR
            \RETURN{$L$}
        \end{algorithmic}
    \end{algorithm}
\end{appendices}

\newpage

\begin{appendices}
    Annexe 3
    \begin{algorithm}
        \caption{brute force correction 1 erreur}
        \begin{algorithmic}
            \REQUIRE $len(P)=len(N)$
            \STATE $L1=[]$
            \FOR {i in range(len(N))}
            \STATE $L=[]$
            \FOR{j in range(len(N))}
            \STATE $N_i=[]$
            \STATE $P_i=[]$
            \FOR{k in range(len(N))}
            \IF{$k\neq i$ and $k\neq j$}
            \STATE $N_i=N_i+[N[k]]$
            \STATE $P_i=P_i+[P[k]]$
            \ENDIF
            \ENDFOR
            \STATE $l=reste-chinois(N_i,P_i)$
            \STATE $L=L+[l]$
            \ENDFOR
            \STATE $L1=L1+[L]$
            \ENDFOR
            \RETURN{$L1$}
        \end{algorithmic}
    \end{algorithm}
\end{appendices}

\newpage

\begin{appendices}
    Annexe 4 \newline
    Cette algorithme prend en paramètre la liste des modulos, la liste des restes, et le nombre d'erreur. Et retourne la liste des candidats.
    \begin{algorithm}
        \caption{brute force de hamming}
        \begin{algorithmic}
            \STATE $n=len(N)$
            \STATE $cpt=0 $
            \STATE $N=1$
            \STATE $borne=0$
            \FOR{i in range(n)}
            \STATE $N=N\times P[i]$
            \STATE $borne=borne+ (P[i]-1)$
            \ENDFOR
            \STATE $borne=N//borne$
            \STATE $(a,L-force)= generateur-de-cas(N,cpt) $
            \STATE $l-candidat=[]$
            \WHILE{$cpt \leq borne$}
            \IF{$distance-hamming(L-force,N) \leq nb-erreur$}
            \STATE $l-candidat = l-candidat+[cpt]$
            \ENDIF
            \STATE $cpt=cpt+1$
            \STATE $(a,L-force)=genrateur-de-cas(N,cpt)$
            \ENDWHILE
            \RETURN{l-candidat}
        \end{algorithmic}
    \end{algorithm}
\end{appendices}

\newpage

\begin{appendices}
    Annexe 5
    Cette fonction prend en paramètre la liste des $p_i$ la liste des restes modulos les $p_i$, et le nombre d'erreur.
    \begin{algorithm}
        \caption{fraction continue}
        \begin{algorithmic}
            \STATE $k=reste-chinois(P,N)$
            \STATE $p=1$
            \STATE $n=1$
            \STATE $L=[]$
            \FOR{i in range(len(P))}
            \STATE $n=n\times P[i]$
            \ENDFOR
            \STATE $borne=max-borne-frac(N,nb-erreur)$
            \STATE $b=0$
            \WHILE{$b\leq borne$}
            \STATE $L1= fraction-reduite(k,n,p)$
            \STATE $(a,d)=list-int-reduite(L1)$
            \STATE $L2=decompose-liste(b,N)$
            \IF{$L2\neq -1$ and $L2\neq []$}
            \STATE $L=L+[L2]$
            \ENDIF
            \STATE $p=p+1$
            \ENDWHILE
            \RETURN{$L$}
        \end{algorithmic}
    \end{algorithm}
\end{appendices}
\end{document}